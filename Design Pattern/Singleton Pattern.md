# 정의

객체의 인스턴스가 오직 1개만 생성되는 패턴

싱글톤 패턴을 구현하는 방법은 여러가지가 있지만, 객체를 미리 생성해두고 가져오는 가장 단순하고 안전한 방법을 소개한다.
```java
public class Singleton {
    private static Singleton instance = new Singleton();

    private Singleton() {
        // 생성자는 외부에서 호출하지 못하게 private로 지정한다.
    }

    public static Singleton getInstance() {
        return instance;
    }

    public void say() {
        System.out.println("hello");
    }
}
```

# 사용하는 이유

```
크게 메모리와 데이터 공유에 대한 이점이 있다.
메모리의 경우 한번의 new로 계속 사용가능한 점.
데이터 공유의 경우 전역 인스턴스인 점.
```
인스턴스를 오직 한 개로만 가져가면 **메모리**와 **데이터 공유**에 대한 부분의 이점이 있다.

메모리는 최초 한번의 new 연산자를 통해 고정된 메모리 영역을 사용하기 때문에 추후 해당 객체에 접근할 때 메모리의 낭비를 방지할 수 있다. 또한 이미 생성된 인스턴스를 활용하기 때문에 속도 측면에서도 이점이 있다.

데이터 공유는 인스턴스가 전역으로 사용되는 인스턴스이기 때문에 다른 클래스의 인스턴스들이 접근하여 사용할 수 있다. 하지만 여러 클래스의 인스턴스에서 싱글톤 인스턴스의 데이터에 동시에 접근하게 되면 동시성 문제가 발생할 수 있으니 주의해서 설계해야 한다.

이 외의 도메인 관점에서 인스턴스가 한 개만 존재하는 것을 보증하고 싶은 경우 싱글톤 패턴을 사용하기도 한다.

# 문제점

```
1. 코드가 길어진다.
2. 테스트가 어려워진다.
3. SOLID원칙 중 DIP를 위반한다.
```

싱글톤 패턴을 구현하는 코드 자체가 많이 필요하다. [정적 팩토리 메소드](/Design%20Pattern/Singleton%20Pattern.md)에서 객체 생성을 확인하고 생성자를 호출하는 경우 멀티쓰레딩 환경에서 발생할 수 있는 동시성 문제 해결을 위해 `syncronized`를 사용해야 한다.

테스트하기 어렵다는 점도 있다. 싱글톤 인스턴스는 자원을 공유하기 때문에 테스트가 결정적으로 격리된 환경에서 수행되려면 매번 인스턴스의 상태를 초기화시켜주어야 한다. 그렇지 않으면 어플리케이션 전역에서 상태를 공유하기 때문에 테스트가 온전하게 수행되지 못한다.

의존 관계상 클라이언트가 구체 클래스에 의존하게 된다. new 키워드를 직접 사용하여 클래스 안에서 객체를 생성하고 있으므로, 이는 [SOLID원칙](/Java/%EA%B0%9D%EC%B2%B4%EC%99%80%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5.md) 중 DIP를 위반하게 되고 OCP원칙 또한 위반할 가능성이 높다.

이 외에 자식클래스 생성 불가, 내부 상태 수정이 어렵다는 점 등 여러가지 문제점이 있다.   
=> 싱글톤 패턴은 유연성이 많이 떨어지는 패턴이다.

# 결론
```
프레임워크의 도움을 받아 사용하는게 편하지만
없이 사용하려면 장단점을 잘 고려해야 한다.
```
오직 한개의 인스턴스 생성을 보증하여 효율을 찾을 수 있찌만 그에 못지않게 수반되는 문제점도 많다. 싱글톤 패턴은 안티패턴이라고 불릴 만큼 단독으로 사용한다면 객체 지향에 위배되는 사례가 많다. 스프링 컨테이너 같은 프레임워크의 도움을 받으면 싱글톤 패턴의 문제점을 보완하며 장점의 혜택을 누릴 수 있다.

프레임워크의 도움없이 싱글톤 패턴을 적용하고 싶다면, 장단점의 trade-off를 잘 고려하여 사용해야 한다.

# 출처

[싱글톤 패턴이란?](https://tecoble.techcourse.co.kr/post/2020-11-07-singleton/)